<!DOCTYPE HTML>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>Chez Earth</title>
        <style type="text/css">
            body {
                margin: 0;
                overflow: hidden;
            }
            canvas {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <script src="js/three.min.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script id="vertex_shader" type="x-shader/x-vertex">
// Implicit attributes:
//  vec3 position   // The location of the vertex in object coords
//  vec3 normal     // The normal in object frame
//  vec2 uv         // The texture coords
// Implicit uniforms:
//  mat4 projectionMatrix   // From camera to "screen"
//  mat4 modelMatrix        // Object to world
//  mat4 viewMatrix         // World to camera
//  mat4 modelViewMatrix    // Object to camera
//  mat3 normalMatrix       // Upper 3x3 of modelViewMatrix (obj -> camera)
//  vec3 cameraPosition
attribute vec4 tangent;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vTangent;
varying vec3 vBinormal;
varying vec3 vSurfaceToEye;

void main() {
    vUv = uv;

    vNormal = normalize(normalMatrix * normal);
    vTangent = normalize(normalMatrix * tangent.xyz);
    vBinormal = normalize(cross(vNormal, vTangent) * tangent.w);

    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    vSurfaceToEye = -mvPosition.xyz;

    gl_Position = projectionMatrix * mvPosition;
}
        </script>
        <script id="fragment_shader" type="x-shader/x-fragment">
uniform sampler2D s_day;
uniform sampler2D s_night;
uniform sampler2D s_normal;
uniform sampler2D s_specular;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vTangent;
varying vec3 vBinormal;
varying vec3 vSurfaceToEye;

void main() {
    vec4 tColor = texture2D(s_day, vUv);
    vec4 tColor2 = texture2D(s_night, vUv);
    vec3 normal_map = (texture2D(s_normal, vUv).xyz * 2.0) - 1.0;
    normal_map.xy *= 0.05;
    normal_map = normalize(normal_map);
    float kSpecular = texture2D(s_specular, vUv).x * 0.5 + 0.0;

    mat3 tbn = mat3(vTangent, vBinormal, vNormal);

    vec3 normal = normalize(tbn * normal_map.xyz);
    vec3 surfaceToLightDir = normalize(vec3(2.0, 0.3, 1.0));

    float nDotL = dot(normal, surfaceToLightDir);
    // R = the reflection of surfaceToLightDir (L) about the normal
    vec3 R = (2.0 * normal * nDotL) - surfaceToLightDir;
    float rDotV = dot(R, normalize(vSurfaceToEye));
    vec3 specular = vec3(kSpecular * pow(max(0.0, rDotV), 20.0)) * 0.5;
    float night = (1.0 - smoothstep(-0.3, 0.2, nDotL)) * 0.1;
    float day = max(0.0, nDotL);

    vec3 color = (tColor2.rgb * night) + (tColor.rgb * day) + specular;
    gl_FragColor = vec4(color * 1.5, 1.0);
}
        </script>
        <script id="flash_vertex_shader" type="x-shader/x-vertex">
uniform float time;

varying vec2 vUv;

void main() {
    vUv = uv;

    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    gl_Position = projectionMatrix * mvPosition;
}
        </script>
        <script id="flash_fragment_shader" type="x-shader/x-fragment">
uniform float time;

varying vec2 vUv;

void main() {
    float x = vUv.x - 0.5;
    float y = vUv.y - 0.5;
    float r = (0.25 - (x*x + y*y)) * time;
    gl_FragColor = vec4(r, r, 0.0, 1.0);
}
        </script>
        <script>
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 10);
            var renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            var day = THREE.ImageUtils.loadTexture('day.jpg');
            var night = THREE.ImageUtils.loadTexture('night.jpg');
            var normal = THREE.ImageUtils.loadTexture('normal.png');
            var specular = THREE.ImageUtils.loadTexture('specular.png');

            function getShader(name) {
                return document.getElementById(name).textContent;
            }

            var material = new THREE.ShaderMaterial({
                attributes: {},
                uniforms: {
                    s_day: {type: 't', value: day},
                    s_night: {type: 't', value: night},
                    s_normal: {type: 't', value: normal},
                    s_specular: {type: 't', value: specular}
                },
                vertexShader: getShader('vertex_shader'),
                fragmentShader: getShader('fragment_shader')
            });

            var radius = 1.0;
            var geometry = new THREE.SphereGeometry(radius, 80, 60);
            geometry.computeTangents();
            var globe = new THREE.Mesh(geometry, material);
            scene.add(globe);

            geometry = new THREE.PlaneGeometry(0.2, 0.2);
            material = new THREE.MeshBasicMaterial({side: THREE.DoubleSide});
            material = new THREE.ShaderMaterial({
                uniforms: {
                    time: {type: 'f', value: 1.0}
                },
                vertexShader: getShader('flash_vertex_shader'),
                fragmentShader: getShader('flash_fragment_shader'),
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            var plane = new THREE.Mesh(geometry, material);
            plane.position.z = radius * 1.001;
            globe.add(plane);

            camera.position.z = 2.6;
            camera.lookAt(scene.position);

            var orbitControls = new THREE.OrbitControls(camera);
            orbitControls.userPan = false;

            var clock = new THREE.Clock();

            function render() {
                // Time since last frame / seconds
                var delta = clock.getDelta();
                orbitControls.update(delta);
                globe.rotation.y += delta / 40;
                var time = material.uniforms.time.value;
                if (time > 0.01) {
                    time *= 0.4;
                } else {
                    time = 1.0;
                }
                material.uniforms.time.value = time;

                requestAnimationFrame(render);
                renderer.render(scene, camera);
            }
            render();
        </script>
    </body>
</html>
